"""Index cycles for a 3 × 3 × 3 Rubik’s Cube – half‑turn metric (U, R, F, D, L, B + primes + double turns).

The cube is represented as a 54‑element facelet array in **Singmaster order**
U → R → F → D → L → B, each face enumerated row‑major left‑to‑right, top‑to‑bottom:

    U: 0 … 8   R: 9 … 17   F: 18 … 26
    D: 27 … 35  L: 36 … 44  B: 45 … 53

For a clockwise quarter‑turn of a face (as seen *looking directly at that face*),
we need two kinds of cycles:
  • the **face cycles** – corners and edges that remain on the same face;
  • the **rim cycles** – rows/columns on the adjacent faces that are carried
    around the cube.

Quarter‑turn (**HTM**) permutations are given as 4‑cycles.  Their *prime* (CCW)
variants are simply those cycles reversed.  **Half‑turns** are generated by
splitting every 4‑cycle into **two disjoint 2‑cycles** – this swaps opposite
stickers and fixes the bugs you saw with R2, F2, D2, L2, and B2.
"""
from __future__ import annotations

MOVES: dict[str, tuple[tuple[int, ...], ...]] = {}

# ────────────────────────────────────────────────────────────────────────────────
# Helpers
# ────────────────────────────────────────────────────────────────────────────────

def faces(c: int):
    """Corner / edge 4‑cycles for a clockwise rotation of the face whose upper‑left
    sticker is at index *c*.

    Corner order is UL → DL → DR → UR (indices c, c+6, c+8, c+2).
    Edge   order is UM → LM → DM → RM (indices c+1, c+3, c+7, c+5).
    """
    return (
        (c,   c + 6, c + 8, c + 2),  # corners
        (c+1, c + 3, c + 7, c + 5),  # edges
    )

# ────────────────────────────────────────────────────────────────────────────────
# Rim cycles (clockwise)
# ────────────────────────────────────────────────────────────────────────────────
# U (0)… F top → R top → B top → L top
UF = [(18,  9, 45, 36), (19, 10, 46, 37), (20, 11, 47, 38)]

# R (9)… U right → F right → D right → B left
RF = [(2,  20, 29, 45), (5, 23, 32, 48), (8, 26, 35, 51)]

# F (18)… U bottom → R left → D top → L right
FF = [(6,   9, 27, 44), (7, 12, 28, 41), (8, 15, 29, 38)]

# D (27)… F bottom → R bottom → B bottom → L bottom
DF = [(24, 15, 51, 42), (25, 16, 52, 43), (26, 17, 53, 44)]

# L (36)… U left → B right → D left → F left
LF = [(0, 18, 27, 53), (3, 21, 30, 50), (6, 24, 33, 47)]

# B (45)… U top (reversed) → R right → D bottom (reversed) → L left
BF = [(2, 11, 35, 36), (1, 14, 34, 39), (0, 17, 33, 42)]

# ────────────────────────────────────────────────────────────────────────────────
# Build the lookup table – 18 moves (quarter/half turns in HTM)
# ────────────────────────────────────────────────────────────────────────────────

base = {
    'U': faces(0)   + tuple(UF),
    'R': faces(9)   + tuple(RF),
    'F': faces(18)  + tuple(FF),
    'D': faces(27)  + tuple(DF),
    'L': faces(36)  + tuple(LF),
    'B': faces(45)  + tuple(BF),
}

for k, v in base.items():
    # Clockwise quarter‑turn
    MOVES[k] = v

    # Counter‑clockwise prime – reverse every cycle
    MOVES[k + "'"] = tuple(tuple(reversed(c)) for c in v)

    # Half‑turn – split each 4‑cycle into two disjoint 2‑cycles
    half: list[tuple[int, int]] = []
    for cyc in v:
        if len(cyc) == 4:
            half.append((cyc[0], cyc[2]))  # swap opposite stickers
            half.append((cyc[1], cyc[3]))
        else:  # 2‑cycle already – leave as‑is (shouldn’t occur here)
            half.append(cyc)               # type: ignore[arg‑type]
    MOVES[k + '2'] = tuple(half)

# Convenience – ordered list of all move tags
MOVE_TAGS = tuple(MOVES.keys())
